# BOJ 14217 그래프 탐색

[BOJ 14217 그래프 탐색](https://www.acmicpc.net/problem/14217)

## 문제

남규나라의 왕 zych는 도로 정비 계획을 발표하였다. 두 도시를 잇는 도로들을 새로 만들거나, 안전상의 문제로 도로를 없애기도 할 계획이다. 도로 정비 계획은 두 도시와, 만들건지, 없앨건지에 대한 정보가 주어지는데, 도로를 정비하는 일은 매우 큰 일이기에 계획을 순서대로 하나씩 시행해 나갈 것이다. 상황에 따라서는 계획에 포함돼서 만들어진 도로를 제거할 수도 있다.

Zych는 차후 도로 정비 계획에 참고하기 위하여, 각 도시들이 수도에 방문하는데 최소 몇 개의 도시들을 방문해야 하는지 조사하기로 하였다.

남규나라의 초기 도시상태가 주어지고 도로 정비계획이 주어질 때, 한 도로가 정비될 때마다 각 도시별로 수도를 방문하는 데 최소 방문 도시들을 출력하시오.

### 입력

첫째 줄에는 도시의 개수 n,도로의 개수 m이 주어진다. 다음 m개의 줄에는 두 도시가 주어진다.(2≤n≤500,1≤m≤n\*(n-1)/2)

다음 줄에는 도로 정비 계획에 들어가 있는 도로의 수 q가 주어지고, 다음 q줄에는 a i j가 주어지는데, a가 1일때는 두 도시 i,j를 잇는 도로를 만들고, a가 2일때는 i,j를 잇는 도로를 없앤다. (1≤q≤500,1≤a≤2, 1≤i,j≤n)

두 도시 사이에 이미 도로가 있는데 또 도로를 만들거나, 도로가 없는데 없애는 불가능한 경우는 입력으로 들어오지 않는다.

수도는 1번도시이다.

### 출력

q줄에 각 도시별로 수도를 방문하는 데 최소 방문 도시들을 출력하시오. 만약 수도를 방문하지 못한다면 -1을 출력하시오.

#### 문제풀이

처음에는 모든 도시마다 수도까지의 거리를 구하기 위해 모든 도시로부터 출발하여 1까지 도착하는 bfs를 돌려서 시간초과가 났다.
하지만 1번노드에서 n번노드로 가는 것과 n번 노드에서 1번 노드로 가는 거리가 동일하다는 것을 생각하면 bfs를 1번만 돌려도 문제를 해결할 수 있다. n번 노드에서 1번 노드로 가는 것을 구하는 것이 아니라 반대로 1번 노드에서 n번 노드로 가는 거리를 구하면 동일한 값을 얻을 수 있다.

```python
import sys
from collections import deque
input = sys.stdin.readline

def bfs(i):
    global arr
    visited = [-1 for _ in range(n)] # 전체 route를 -1로 초기화
    visited[i-1] = 0 # 수도인 '1'은 자신에서 자신으로 가는 거리가 0이니까 0로 초기화
    q = deque([i])
    while q:
        print(q)
        item = q.popleft()  # 현재 확인할 위치
        # 여기가 포인트!
        for i in arr[item]:  # 현재 확인할 위치에 연결된 노드들을 순서대로 확인
            if visited[i-1] == -1: # 연결된 노드에 방문한 적이 없으면
                visited[i-1] = visited[item-1] + 1  # 현재 위치에서 넘어갈거니까 현재 위치에 visited + 1
                q.append(i) # 연결된 노드를 queue에 추가하여 다음에 확인
    return visited

n, m = map(int, input().split())
arr = [[] for _ in range(n+1)]
for _ in range(m):
    i, j = map(int, input().split())
    arr[i].append(j) # adj 작성 (왕복 가능하니까 반대로 가는 길도 생성)
    arr[j].append(i)

q = int(input())

for _ in range(q):
    a, i, j = map(int, input().split())
    if a == 1:
        arr[i].append(j) # adj에 추가(왕복 가능하니까 반대로 가는 길도 생성)
        arr[j].append(i)
    else:
        arr[i].remove(j) # adj에서 삭제 (왕복 가능하니까 반대로 가는 길도 삭제)
        arr[j].remove(i)

    print(*bfs(1))

```
