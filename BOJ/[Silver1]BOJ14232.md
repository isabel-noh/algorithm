# BOJ - Silver1 - 보석 도둑

[BOJ - Silver1 - 보석 도둑](https://www.acmicpc.net/problem/14232)

### 문제

희대의 도둑 효빈이는 세계 최고의 보석가게 영선상에 잠입할 계획이다. 이 영선상은 최고의 보석가게답게 최고의 보안장치를 두고 있는데, 이 보안장치를 해제하지 않는다면 보석을 여러 개 훔쳐갈 시, 보석끼리 달라붙으며 무게가 모든 보석들의 곱으로 늘어난다.

효빈이는 이 보안장치를 해제할 수 없기 때문에, 차라리 곱해진 대로 최대한 많은 보석들을 가져오기로 계획했다. 효빈이는 한번에 k라는 무게를 들 수 있으므로, 딱 k만큼의 무게만큼의 보석을 가져오고 싶은데, 그 때 보석들의 최대 개수를 알고싶다.

영선상에는 세계 최고의 보석가게답게 모든 무게의 보석들이 매우 많이때문에, 훔쳐가는 보석이 부족할 일은 없다. 다만 모든 보석들은 무게가 1보다 크다.

효빈이는 이제 영선상에 잡입할 계획을 다 세웠다. 하지만 무슨 보석들을 훔쳐올지 결정하지 못하였는데, 효빈이를 대신하여 훔쳐올 보석들을 결정해주자.

### 입력

첫째 줄에는 효빈이가 들 수 있는 무게 k가 주어진다.(2≤k≤1012)

### 출력

첫째 줄에는 효빈이가 훔쳐올 보석의 개수를 출력하고, 다음 줄에는 훔쳐올 보석들의 무게를 오름차순으로 출력하시오.

### 알고리즘 설계

### 코드

```js
const fs = require("fs");
// 약수의 나열

// 시간 초과
let k = Number(fs.readFileSync("./sample.txt"));
const arr = [];
let n = 2;
while (k > 1) {
  if (k % n === 0) {
    k = k / n;
    arr.push(n);
  } else {
    n += 1;
  }
}
```

```js
while (k > 1 && Math.sqrt(k) + 1 >= n) {
  if (k % n === 0) {
    arr.push(n);
    k = k / n;
  } else {
    n += 1;
  }
}
```

```js
for (let i = 2; i < parseInt(Math.sqrt(k)) + 1; i++) {
  // 2부터 k의 제곱근까지
  while (k % i === 0) {
    arr.push(i);
    k = k / i;
  }
}
if (k !== 1) arr.push(k);
console.log(arr.length);
console.log(arr.join(" "));
```

### 기억해야할 것

에라토스테네스의 체
에라토스테네스의 체란 소수를 판별하는 알고리즘이다. 소수들을 대량으로 빠르고 정확하게 구하는 방법이다.
어떤 수 N의 소수 여부를 구할 때에는, 그 숫자 N의 제곱근까지만 약수 여부를 검증하면 됨.
그 숫자 N를 나누는 다른 어떤 수와 그에 대한 몫 중 하나는 N의 제곱근 이하이기 때문임.

에라토스테네스의 체 원리
소수를 판별할 범위만큼 배열을 할당하여, 해당하는 값을 넣어주고, 이후에 하나씩 지워나가는 방법을 이용한다.
