# BOJ 2011 암호코드
# [BOJ 2011 암호코드](https://www.acmicpc.net/problem/2011)
## 문제
# 상근이와 선영이가 다른 사람들이 남매간의 대화를 듣는 것을 방지하기 위해서 대화를 서로 암호화 하기로 했다. 그래서 다음과 같은 대화를 했다.

# 상근: 그냥 간단히 암호화 하자. A를 1이라고 하고, B는 2로, 그리고 Z는 26으로 하는거야.
# 선영: 그럼 안돼. 만약, "BEAN"을 암호화하면 25114가 나오는데, 이걸 다시 글자로 바꾸는 방법은 여러 가지가 있어.
# 상근: 그렇네. 25114를 다시 영어로 바꾸면, "BEAAD", "YAAD", "YAN", "YKD", "BEKD", "BEAN" 총 6가지가 나오는데, BEAN이 맞는 단어라는건 쉽게 알수 있잖아?
# 선영: 예가 적절하지 않았네 ㅠㅠ 만약 내가 500자리 글자를 암호화 했다고 해봐. 그 때는 나올 수 있는 해석이 정말 많은데, 그걸 언제 다해봐?
# 상근: 얼마나 많은데?
# 선영: 구해보자!
# 어떤 암호가 주어졌을 때, 그 암호의 해석이 몇 가지가 나올 수 있는지 구하는 프로그램을 작성하시오.

# ### 입력
# 첫째 줄에 5000자리 이하의 암호가 주어진다. 암호는 숫자로 이루어져 있다.

# ### 출력
# 나올 수 있는 해석의 가짓수를 구하시오. 정답이 매우 클 수 있으므로, 1000000으로 나눈 나머지를 출력한다.

# 암호가 잘못되어 암호를 해석할 수 없는 경우에는 0을 출력한다.

# from itertools import combinations

# N = list(input())
# count = 0
# 메모리 초과
# for i in range(len(N)):
#     if N[0] == '0':                     # 맨 앞자리가 0인 경우, 잘못된 암호
#         break
#     # 0 ~ len(N)까지의 조합 배열 생성
#     # 여기에서 메모리 초과 발생
#     a = (list(combinations(list(i for i in range(len(N))), i+1)))
#     for b in a:
#         dp = [0]*len(N)                  # [0, 0, 0, ... , 0] 
#         for c in b:                     # 조합 배열에 있으면 해당 배열에 1로 표시 ( 0은 뒤에 붙을 애들, 1은 해당 자리 차지하는 숫자)
#             dp[c] = 1
#         arr = []
#         for m in range(len(dp)):         # n 배열은 각 숫자가 포함되냐 안되냐를 표기한 것  -> [2, 5, 1, 14] 이런식으로 들어감
#             k = ''
#             if dp[m] == 0 :
#                 if len(arr) == 0:
#                     break
#                 else:
#                     arr[-1] += str(N[m])
#             else: 
#                 arr.append(str(N[m]))
#         if arr == []:
#             continue
#         else: 
#             flag = True
#             for r in arr :
#                 if 1 <= int(r) <= 26 :  # 해당 값이 26이 넘어가면 잘못된 암호분석이므로 패스
#                     break
#                 else:
#                     flag = False
#                     break
#             if flag == True:
#                 count += 1

# if N[0] == '0':
#     print(0)
# else:
#     print(count%1000000)

# dp 해설 참고 (경우의 수로 문제를 해결해야 함)

N = list(input())
dp = [0 for _ in range(len(N)+1)]                     # [0, 0, 0, 0, 0, 0] 
dp[0] = 1 # 후에 전전 값을 이어 받을 상황을 위해 padding 설치  # [1, 0, 0, 0, 0, 0] 
dp[1] = 1 # 첫번째 자리는 경우의 수가 무조건 1가지            # [1, 1, 0, 0, 0, 0] 

if N[0] == '0':                                      # 첫번째 값부터 0이면 암호 성립 X
    print(0)
    quit()

for i in range(2, len(N)+1): 

    if int(N[i-1]) > 0 : # 전 값이 0이 아니고 자연수이면 
        dp[i] += dp[i-1] # dp(경우의 수)에서 전 값을 그대로 이어감 (앞의 자리수 까지에서의 경우의 수에서 변동 없음)
    print('1', dp)

    if 10 <= int(N[i-2] + N[i-1]) <= 26 : # 이어붙였을 때 10~26 사이이면 
        dp[i] += dp[i-2]    # dp(경우의 수)에서 전전 값을 넘겨받음 

    print('2', dp)
print(dp[-1]%1000000)