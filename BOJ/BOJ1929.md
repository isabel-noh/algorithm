# BOJ 1929 소수구하기  
[BOJ 1929 소수구하기](https://www.acmicpc.net/problem/1929)

## 문제  
M이상 N이하의 소수를 모두 출력하는 프로그램을 작성하시오.

### 입력  
첫째 줄에 자연수 M과 N이 빈 칸을 사이에 두고 주어진다. (1 ≤ M ≤ N ≤ 1,000,000) M이상 N이하의 소수가 하나 이상 있는 입력만 주어진다.

### 출력  
한 줄에 하나씩, 증가하는 순서대로 소수를 출력한다.

#### 문제풀이
소수를 출력하는 문제이다. 처음에는 2에서부터 지금 현재 내 숫자 전까지를 for문으로 돌면서 현재 i의 약수가 나오면 소수가 아닌 것으로 판별을 하였는데 시간 초과가 발생하였다. 
찾아보니 두번째 for문에서 범위가 너무 커져서 시간 초과가 나는 것 같았다. 
`i의 약수는 무조건 i의 제곱근 안의 범위에 존재한다.`
12의 경우, 12의 약수는 1,2,3,4,6,12이다. 1과 12를 제외하면 2,3,4,6 이고 2\*6, 3\*4, 4\*3, 6\*2로 결국 같은 숫자들의 조합이 2번씩 반복된다. 
이들의 관계는 몫이 커지면 나누는 값이 작아지거나 나누는 값이 커지만 몫이 작아지는 반비례 관계이다. 결국 N의 절반(제곱근)까지 향하게 되면 이후 몫과 나누는 값이 반대로 바뀌게만 되는 상황이다.
해당 숫자 (i)의 제곱근((i**0.5)+1)까지 중에 i의 약수를 구할 수 있으면 해당 숫자(i)도 소수가 아니게 된다고 한다. 
11의 경우, 11의 int(제곱근)은 3이고, 11은 2이나 3으로 나눠지지 않으므로 소수인 것이다. 5나 7을 확인하지 않아도 되는 것이다. 
29의 경우, 29의 int(제곱근)은 5이고, 29는 2, 3, 4, 5로 나눠지지 않으므로 소수이다. 
```python

import sys
sys.stdin = open('sample.txt')
M, N = map(int, input().split())
# 3이상 16이하
for i in range(M, N+1):
    if i == 1:
        continue
#     for j in range(2, i):       # 시간초과
    for j in range(2, int(i**0.5)+1):
        if i % j == 0:
            break
    else:
        print(i)
```
