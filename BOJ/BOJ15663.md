# BOJ 15663 N & M (9)  
[BOJ 15663 N & M (9)](https://www.acmicpc.net/problem/15663)  
## 문제  
N개의 자연수와 자연수 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오.
N개의 자연수 중에서 M개를 고른 수열  
### 입력  
첫째 줄에 N과 M이 주어진다. (1 ≤ M ≤ N ≤ 8)
  
둘째 줄에 N개의 수가 주어진다. 입력으로 주어지는 수는 10,000보다 작거나 같은 자연수이다.
  
### 출력  
한 줄에 하나씩 문제의 조건을 만족하는 수열을 출력한다. 중복되는 수열을 여러 번 출력하면 안되며, 각 수열은 공백으로 구분해서 출력해야 한다.
  
수열은 사전 순으로 증가하는 순서로 출력해야 한다.

#### 문제풀이
조건이 많아 난항을 겪었다. 같은 숫자는 들어가면 안되는데, 다른 index에 있던 숫자이면 괜찮다.  [1, 4, 6, 8, 8]일 경우, [1, 1]이나 [6, 6]은 안되지만, [8, 8]은 base 배열에 8이 두번있기 때문에 괜찮다. 
그리고 [7, 1]과 [1, 7]은 또 괜찮다.  다른 사람에게 아이디어를 얻어서 문제를 해결할 수 있었다. 바로 set을 이용하는 것이다. 먼저 visited배열을 만들어서 각 index번째 값을 수열에 넣을 때마다 visited[idx]를 1로 만들어주어 중복되지 않게 하였다. 그렇지만 또 [1, 8(4번)]과 [1, 8(5번)]에서 8의 idx는 다르지만 결과 값이 [1, 8]로 같기 때문에 나타나면 안된다. 이부분을 정리하기 위해 set을 사용하였다. set에는 중복 값이 들어갈 수 없다. 그리고 유의하여야 할 점이 있는데 set에는 고정된 값만 넣을 수 있기 때문에 list는 넣을 수가 없었기 때문에 tuple로 묶어서 넣었다. 이후 sort하여 오름차순으로 정렬하고 출력하였다. 
```python
N, M = map(int, input().split())
arr = sorted(list(map(int, input().split())))
s = []
visited = [0] * N
c = set()
a = []
def f():
    if len(s) == M:
        c.add(tuple(s))
        return

    else:
        for i in range(len(arr)):
            if visited[i] == 1:
                pass
            else:
                s.append(arr[i])
                visited[i] = 1
                f()
                s.pop()
                visited[i] = 0
f()

for i in c:
    a.append(i)
a.sort()
for i in a:
    print(*i)
```

##### 다른 사람의 문제풀이  
r이라는 걸 줘서 r이 L[i]랑 다를 경우만 시행하게 해주었다. r이 뭘까   
r은 각 dfs함수에서 생성된다. 이 r은 각 자리마다 전에 선택되었던 숫자를 저장한다.  
예를 들면 base배열이 [5, 7, 9, 9]이고 3개짜리 수열을 만들어내고자 할 때,  [5, 7, 9]가 전에 생성되었던 수열이라면 첫번째 자리의 r에는 5가 두번째 자리의 r에는 7이 세번째 자리의 r에는 9가 저장되어있을 것이다. 
그다음 수열은 마찬가지로 [5, 7, 9(4번째)]가 될텐데 이미 r이 9로 저장되어있기 때문에 동일한 값을 사용하지 않게된다.   
그러면 [7, 9, 9]도 안되는 것 아니냐? 고 고민했다. 하지만 위에서 말했듯이 각 자리마다 r을 저장하기 때문에 2번째 r이 9이고 3번째r은 또 다른 것 이기 때문에 위 조건에서 걸리지 않는다. 
똑똑한 사람이네 각 함수에서 생기는 변수를 사용하다니  
```python
def dfs():
    if len(s) == m:
        print(*s)
        return
    r = 0
    for i in range(len(L)):
        if visited[i] == 0 and r != L[i]:
            visited[i] = 1
            r = L[i]
            s.append(L[i])
            dfs()
            s.pop()
            visited[i] = 0


n, m = map(int, input().split())
L = sorted(map(int, input().split()))
s = []
visited = [0] * (n+1)
dfs()
```