# BOJ 정수삼각형 1932

[BOJ 정수삼각형 1932](https://www.acmicpc.net/problem/1932)

## 문제

```
        7
      3   8
    8   1   0
  2   7   4   4
4   5   2   6   5
```

위 그림은 크기가 5인 정수 삼각형의 한 모습이다.

맨 위층 7부터 시작해서 아래에 있는 수 중 하나를 선택하여 아래층으로 내려올 때, 이제까지 선택된 수의 합이 최대가 되는 경로를 구하는 프로그램을 작성하라. 아래층에 있는 수는 현재 층에서 선택된 수의 대각선 왼쪽 또는 대각선 오른쪽에 있는 것 중에서만 선택할 수 있다.

삼각형의 크기는 1 이상 500 이하이다. 삼각형을 이루고 있는 각 수는 모두 정수이며, 범위는 0 이상 9999 이하이다.

### 입력

첫째 줄에 삼각형의 크기 n(1 ≤ n ≤ 500)이 주어지고, 둘째 줄부터 n+1번째 줄까지 정수 삼각형이 주어진다.

### 출력

첫째 줄에 합이 최대가 되는 경로에 있는 수의 합을 출력한다.

#### 문제풀이

DP는 어려워2  
위에서부터 차례로 내려오고 최댓값을 찾는 문제라 DP일거라고 생각은 했다.  
처음엔 문제를 잘 못 이해했던 것 같다. 모든 경우의 수를 다 dp에 적어놔야한다고 생각했다.  
하지만 그럴필요가 없었음! dp이기 때문에 오른쪽 왼쪽으로 오는 값들 중 최대값만을 저장하면 되는 것이다.

자, 처음부터 설명해보겠당.  
0번째 줄부터 n-1번째 줄까지 확인할 것이기 때문에 for문 1개를 두었다.  
그 다음, 각 i번째 줄 안에서의 배열의 값들을 확인할 것이기 때문에 for문을 1개 더 두었다. -> 2중 for문!

1. 맨 오른쪽과 맨 왼쪽 값은 위에서 받아오는 값이 1개씩 밖에 없기 때문에 별도로 생각한다. 각 양 끝 값들은 상단에 오른쪽 혹은 왼쪽이 없다.  
   1.1. 맨 왼쪽 dp[i][0]은 arr[0][0]부터 arr[i-1][0]까지 더한 값들 중에 최대값이 모인 값에 arr[i][0]을 더한 값이 된다.
   1.2. 맨 오른쪽 dp[i][i]은 arr[0][0]부터 arr[i-1][i-1]까지 더한 값들 중에 최대값이 모인 값에 arr[i][i]을 더한 값이 된다.
2. 2번째 줄부터 있는 가운데에 해당하여 윗줄에서 고려할 수 있는 값이 왼쪽, 오른쪽 2개 있는 경우를 보자.  
   2.1. 2번째 줄의 arr[2][1]을 보자, 위에서 가져올 수 있는 경우가 2개 있다. `7+3`, `7+8`
   2.2. 위 두 값들 중에서 더 큰 값을 dp 에 저장하고 arr[2][1]을 더하면 dp[2][1]이 가질 수 있는 최댓값을 가지게 된다.
3. 점화식으로 풀면 아래와 같다.

```js
if (j === 0) {
  dp[i][j] = dp[i - 1][j] + arr[i][j];
} else if (j === i) {
  dp[i][j] = dp[i - 1][j - 1] + arr[i][j];
} else {
  dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - 1]) + arr[i][j];
}
```

DP 계속 풀어봐야겠다.

```js
const fs = require("fs");
const [n, ...input] = fs
  .readFileSync("./sample.txt")
  .toString()
  .trim()
  .split("\n");

const arr = input.map((element) => element.split(" ").map((ele) => +ele));

const dp = [...new Array(parseInt(n))].map((e) =>
  new Array(parseInt(n)).fill(0)
);

dp[0][0] = arr[0][0];
for (let i = 1; i < n; i++) {
  for (let j = 0; j <= i; j++) {
    if (j === 0) {
      dp[i][j] = dp[i - 1][j] + arr[i][j];
    } else if (j === i) {
      dp[i][j] = dp[i - 1][j - 1] + arr[i][j];
    } else {
      dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - 1]) + arr[i][j];
    }
  }
}

let result = 0;
for (let i = 0; i < dp.length; i++) {
  const a = Math.max(...dp[i]);
  if (a > result) {
    result = a;
  }
}
console.log(result);
```
