# BOJ - imos - 개똥벌레

[BOJ - imos - 개똥벌레](https://www.acmicpc.net/problem/3020)

## 문제

개똥벌레 한 마리가 장애물(석순과 종유석)로 가득찬 동굴에 들어갔다. 동굴의 길이는 N미터이고, 높이는 H미터이다. (N은 짝수) 첫 번째 장애물은 항상 석순이고, 그 다음에는 종유석과 석순이 번갈아가면서 등장한다.

아래 그림은 길이가 14미터이고 높이가 5미터인 동굴이다. (예제 그림)

이 개똥벌레는 장애물을 피하지 않는다. 자신이 지나갈 구간을 정한 다음 일직선으로 지나가면서 만나는 모든 장애물을 파괴한다.

위의 그림에서 4번째 구간으로 개똥벌레가 날아간다면 파괴해야하는 장애물의 수는 총 여덟개이다. (4번째 구간은 길이가 3인 석순과 길이가 4인 석순의 중간지점을 말한다)

하지만, 첫 번째 구간이나 다섯 번째 구간으로 날아간다면 개똥벌레는 장애물 일곱개만 파괴하면 된다.

동굴의 크기와 높이, 모든 장애물의 크기가 주어진다. 이때, 개똥벌레가 파괴해야하는 장애물의 최솟값과 그러한 구간이 총 몇 개 있는지 구하는 프로그램을 작성하시오.

## 입력

첫째 줄에 N과 H가 주어진다. N은 항상 짝수이다. (2 ≤ N ≤ 200,000, 2 ≤ H ≤ 500,000)

다음 N개 줄에는 장애물의 크기가 순서대로 주어진다. 장애물의 크기는 H보다 작은 양수이다.

## 출력

첫째 줄에 개똥벌레가 파괴해야 하는 장애물의 최솟값과 그러한 구간의 수를 공백으로 구분하여 출력한다.

## 문제 분석

N x H의 크기를 가진 배열에서 위에서 내려오는 장애물 ( i % 2 === 0 )과 아래에서 올라가는 장애물 (i % 2 !== 0)이 있다.  
한 줄에서 지나갈 수 있는 장애물의 개수가 가장 적은 행은 몇 개 이고, 해당 장애물이 몇 개인지 세는 문제이다.

## 알고리즘 설계

배열에 장애물을 표기해주고, 마지막에 for문을 돌면서 장애물의 개수 중 min인 것을 찾아 풀이.

## 처음 코드 -> 메모리 초과

```js
let answer = 0;

function solution(n, h, arr) {
  const imos = [...new Array(h)].map((el) => [...new Array(n)].fill(0));
  for (let i = 0; i < n; i += 2) {
    let height = +arr[i];
    for (let j = 0; j < height; j++) {
      imos[h - j - 1][i] = 1;
    }
  }
  for (let i = 1; i < n; i += 2) {
    let height = +arr[i];
    for (let j = 0; j < height; j++) {
      imos[j][i] = 1;
    }
  }
  let min = n;
  let cnt = 0;
  for (let i = 0; i < imos.length; i++) {
    let breakWall = 0;
    for (let j = 0; j < imos[i].length; j++) {
      if (imos[i][j] == 1) {
        breakWall++;
      }
    }
    if (breakWall === min) {
      cnt++;
    }
    if (breakWall < min) {
      min = breakWall;
      cnt = 1;
    }
  }
  return [min, cnt];
}

solution(+N, +H, input);
```

## 코드

```js
const fs = require("fs");
const [a, ...input] = fs
  .readFileSync("./sample.txt")
  .toString()
  .trim()
  .split("\n");
const [N, H] = a.split(" ");

let answer = 0;

function solution(n, h, arr) {
  const imos = Array(h + 1).fill(0); // 높이가 h인 배열
  for (let i = 0; i < n; i++) {
    const height = +arr[i];
    if (i % 2 === 0) {
      imos[0] += 1; // 아래에서 위로 입장
      imos[height] -= 1; // 퇴장
    } else {
      imos[h - height] += 1;
      imos[h] -= 1;
    }
  }
  let now = 0;
  for (let i = 0; i < h; i++) {
    now += imos[i];
    imos[i] = now;
  }
  let min = Math.min(...imos.slice(0, h - 1));
  let cnt = imos.filter((el) => el === min).length;

  console.log(min, cnt);
}

solution(+N, +H, input);
```

## 시간 복잡도

O(N)

## 틀린 이유

메모리 초과 -> imos 알고리즘을 활용하여 재풀이 하였다.

누적합을 풀이할 때 좋은 알고리즘으로, 입장과 퇴장을 기록하여 그 기록에서 누적합을 통해 값을 구한다.  
1차원 배열에 입장하는 시점에는 +1을, 퇴장하는 시점에는 -1을 기록한다.  
위의 문제의 예시의 경우, [1, 5, 3, 3, 5, 1]에서의 장애물을 2차원 배열에 그리면 아래와 같다.

```js
[
  [0, 1, 0, 1, 0, 1],
  [0, 1, 0, 1, 0, 0],
  [0, 1, 0, 1, 1, 0],
  [0, 1, 0, 0, 1, 0],
  [0, 1, 1, 0, 1, 0],
  [0, 0, 1, 0, 1, 0],
  [1, 0, 1, 0, 1, 0],
];
```

이것을 imos에 맞게 0번째 값의 입, 퇴장을 기록하면 아래와 같이 된다.  
`[1, -1, 0, 0, 0, 0, 0, 0]` 0층에서 입장하고, 1층에서 퇴장한다는 것이다.

1번째 값의 입퇴장도 기록해보자. 장애물이 h층에서 h-height층으로 내려온다. 하지만 imos에서는 방향을 아래에서 위로 기록하고 있기 때문에 입장을 h-height에서 하고, h층에서 퇴장을 하는 것으로 기록을 하겠다.
`[1, -1, 1, 0, 0, 0, 0, -1]`

2번째 값도 입퇴장을 기록한다. `[2, -1, 1, -1, 0, 0, 0, -1]`  
이런식으로 쭉 기록하면 다음과 같은 값이 나온다  
`[3, -1, 1, -1, 1, -1, 1, -3]`

입퇴장을 모두 기록하고 나서는 imos의 0번째부터 i번째까지의 누적합을 구한다.  
`[3, 2, 3, 2, 3, 2, 3, 0]`  
마지막 값을 제외한 각 층의 값은 지나가는 장애물의 개수가 된다.

## 💡 느낀점 or 기억할정보

### imos 알고리즘

imos: 누적합을 구하는 알고리즘  
입장과 퇴장만을 기록한다.

누적합 문제에서 쓸 수 있는 개념  
정해진 구간 내에 시작과 끝이 포함된 부분 집합에 대한 명령이 여러개 들어올 때, 반복적으로 연산하게 되면 연산 시간이 매우 커질 수 있다.
