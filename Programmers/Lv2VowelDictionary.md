# Programmers 완전 탐색 - 모음 사전

[Programmers 완전 탐색 - 모음 사전](https:school.programmers.co.kr/learn/courses/30/lessons/84512)

## 문제 설명

사전에 알파벳 모음 'A', 'E', 'I', 'O', 'U'만을 사용하여 만들 수 있는, 길이 5 이하의 모든 단어가 수록되어 있습니다. 사전에서 첫 번째 단어는 "A"이고, 그다음은 "AA"이며, 마지막 단어는 "UUUUU"입니다.

단어 하나 word가 매개변수로 주어질 때, 이 단어가 사전에서 몇 번째 단어인지 return 하도록 solution 함수를 완성해주세요.

### 제한사항

- word의 길이는 1 이상 5 이하입니다.
- word는 알파벳 대문자 'A', 'E', 'I', 'O', 'U'로만 이루어져 있습니다.

### 입출력 예

| word    | result |
| ------- | ------ |
| "AAAAE" | 6      |
| "AAAE"  | 10     |
| "I"     | 1563   |
| "EIO"   | 1189   |

#### 문제풀이

단어의 길이만큼 한단어씩 잘라서 앞에 단어가 몇 개 있는지를 계산하는 방식으로 문제를 풀이하였다.

먼저 한단어만 있을 때를 생각해보자.

A -> 1번째이다.
길이가 2인 A로 시작하는 단어는 5개이다. AA, AE, AI, AO, AU
길이가 3인 A로 시작하는 단어는 5 \* 5개이다. 2번째 자리에 들어갈 수 있는 알파벳 모음의 개수가 'A', 'E', 'I', 'O', 'U' 5개, 3번째 자리에 들어갈 수 있는 알파벳 모음의 개수도 5개이므로 경우의 수는 5 \* 5 = 25개 인 것이다.  
같은 원리로, 길이가 4인 A로 시작하는 단어는 5 \* 5 \* 5 개이다. 2번째 자리에 들어갈 수 있는 알파벳 모음의 개수가 'A', 'E', 'I', 'O', 'U' 5개, 3번째 자리에 들어갈 수 있는 알파벳 모음의 개수도 5개, 4번째 자리에 들어갈 수 있는 알파벳 모음의 개수도 5개 이므로 경우의 수는 5 \* 5 \* 5 = 125개 인 것이다.  
길이가 5인 A로 시작하는 단어는 5 \* 5 \* 5 \* 5 = 625개이다.  
이 모두를 합치면 625 + 125 + 25 + 5 + 1 = 781이 된다.  
E -> 앞에 단어가 781개 있다. 782번째이다.  
위와 같은 원리로 E로 시작하는 단어의 개수도 781개이다.  
I -> 앞에 단어가 781+781개 있다. 1563번째이다.  
위와 같은 원리로 O로 시작하는 단어의 개수도 781개이다.  
O -> 앞에 단어가 781+781+781개 있다. 2344번째이다.  
위와 같은 원리로 O로 시작하는 단어의 개수도 781개이다.  
U -> 앞에 단어가 781+781+781+781개 있다. 3125번째이다.

그러면 길이가 2개인 경우는 어떻게 찾을까?
AE라고 가정해보자.
A부터 시작하니까, 첫번째 자리만 확인한 경우에는 A는 1번째이므로, 1번째 이후이다. 두 번째 자리를 확인해보자. AE 앞에는 몇 개가 있을까? AA로 시작하는 단어들이 될 것이고, 그 단어의 개수는 길이 3 짜리 5개와 길이 4짜리 5 \* 5와 길이 5짜리 5 \* 5 \* 5개가 있을 것이다.
그 모든 개수를 더한 값 + 1이 AE의 위치가 된다.

위의 설명을 코드로 정리해보자.

cal()이라는 함수에서는 지금 몇 번째 글자를 확인하는지 알려주는 index를 인자로 받는다.  
index가 0이라면, r에는 1 + 5 + 5 \* 5 + 5 \* 5 \* 5 + 5 \* 5 \* 5 \* 5 = 781만큼이 더해진다.  
index가 1이라면, r에는 1 + 5 + 5 \* 5 + 5 \* 5 \* 5 = 156만큼이 더해진다.  
index가 2이라면, r에는 1 + 5 + 5 \* 5 = 31만큼이 더해진다.  
index가 3이라면, r에는 1 + 5 = 6만큼이 더해진다.  
index가 4이라면, r에는 1만큼이 더해진다.

0번째 index에서는 A와 E의 차이, E와 I의 차이, I와 O의 차이, O와 U의 차이가 781이라는 의미이다.  
1번째 index에서는 A와 E의 차이, E와 I의 차이, I와 O의 차이, O와 U의 차이가 156이라는 의미이다.  
2번째 index에서는 A와 E의 차이, E와 I의 차이, I와 O의 차이, O와 U의 차이가 31이라는 의미이다.  
3번째 index에서는 A와 E의 차이, E와 I의 차이, I와 O의 차이, O와 U의 차이가 6이라는 의미이다.  
4번째 index에서는 A와 E의 차이, E와 I의 차이, I와 O의 차이, O와 U의 차이가 1이라는 의미이다.

그렇기 때문에 i가 0인 경우, word[i]가 arr[l]의 글자와 동일하다면, cntFormerWords인 781이 l번 곱해진 값에 현재 위치인 1을 누적하여 값을 구하였다.

```js
function solution(word) {
  var answer = 0;
  const arr = ["A", "E", "I", "O", "U"];

  function cal(index) {
    let r = 0;
    for (let i = 0; i < 5 - index; i++) {
      let s = 1;
      for (let j = 0; j < i; j++) {
        s *= 5;
      }
      r += s;
    }
    return r;
  }

  for (let i = 0; i < word.length; i++) {
    let cntFormerWords = cal(i);
    for (let l = 0; l < 5; l++) {
      if (word[i] === arr[l]) {
        answer += 1 + cntFormerWords * l;
      }
    }
  }
  return answer;
}
```

- 초기 코드...

```js
function solution(word) {
  var answer = 0;
  // A E I O U
  // 길이 5 이하의 모든 단어
  // A, AA, AAA, AAAA, AAAAA, AAAAE, ... , UUUUU
  const arr = ["A", "E", "I", "O", "U"];
  for (let i = 0; i < word.length; i++) {
    if (i === 0) {
      for (let l = 0; l < 5; l++) {
        if (word[i] === arr[l]) {
          answer += 1 + 781 * l;
        }
      }
    } else if (i === 1) {
      for (let l = 0; l < 5; l++) {
        if (word[i] === arr[l]) {
          answer += 1 + 156 * l;
        }
      }
    } else if (i === 2) {
      for (let l = 0; l < 5; l++) {
        if (word[i] === arr[l]) {
          answer += 1 + 31 * l;
        }
      }
    } else if (i === 3) {
      for (let l = 0; l < 5; l++) {
        if (word[i] === arr[l]) {
          answer += 1 + 6 * l;
        }
      }
    } else if (i === 4) {
      for (let l = 0; l < 5; l++) {
        if (word[i] === arr[l]) {
          answer += 1 + 1 * l;
        }
      }
    }
  }
  console.log(answer);
  return answer;
}
```
