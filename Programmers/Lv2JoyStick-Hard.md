# Programmers - Greedy - 조이스틱

[Programmers - Greedy - 조이스틱](https://school.programmers.co.kr/learn/courses/30/lessons/42860)

## 문제 설명

조이스틱으로 알파벳 이름을 완성하세요. 맨 처음엔 A로만 이루어져 있습니다.  
ex) 완성해야 하는 이름이 세 글자면 AAA, 네 글자면 AAAA

조이스틱을 각 방향으로 움직이면 아래와 같습니다.

▲ - 다음 알파벳  
▼ - 이전 알파벳 (A에서 아래쪽으로 이동하면 Z로)  
◀ - 커서를 왼쪽으로 이동 (첫 번째 위치에서 왼쪽으로 이동하면 마지막 문자에 커서)  
▶ - 커서를 오른쪽으로 이동 (마지막 위치에서 오른쪽으로 이동하면 첫 번째 문자에 커서)

예를 들어 아래의 방법으로 "JAZ"를 만들 수 있습니다.

- 첫 번째 위치에서 조이스틱을 위로 9번 조작하여 J를 완성합니다.
- 조이스틱을 왼쪽으로 1번 조작하여 커서를 마지막 문자 위치로 이동시킵니다.
- 마지막 위치에서 조이스틱을 아래로 1번 조작하여 Z를 완성합니다.

따라서 11번 이동시켜 "JAZ"를 만들 수 있고, 이때가 최소 이동입니다.

만들고자 하는 이름 name이 매개변수로 주어질 때, 이름에 대해 조이스틱 조작 횟수의 최솟값을 return 하도록 solution 함수를 만드세요.

### 제한 사항

- name은 알파벳 대문자로만 이루어져 있습니다.
- name의 길이는 1 이상 20 이하입니다.

### 입출력 예

| name     | return |
| -------- | ------ |
| "JEROEN" | 56     |
| "JAN"    | 23     |

#### 문제풀이

주어진 name의 길이만큼 동일한 길이의 'A'로만 이루어진 문자열을 주어진 name과 같은 문자열로 바꾸는 것을 요구한다. 여기에서는 4가지의 동작 방식이 존재한다.

1. 알파벳을 다음 알파벳으로 바꾸기 (A -> B, F -> G, ...)
2. 알파벳을 이전 알파벳으로 바꾸기 (C -> B, Z -> Y, A -> Z, ...)
3. 커서를 왼쪽 문자열로 옮기기 (4번째 문자열에서 3번째 문자열로 이동)
4. 커서를 오른쪽 문자열로 옮기기 (4번째 문자열에서 5번째 문자열로 이동)

각 동작은 하나의 액션으로 취급하고 answer 에서 1씩 추가되는 액션이다.

> 'AAA'에서 'JAZ'가 되는 경우는 최소 몇 번의 액션을 행해야 할까?

0번째 index에서 A에서 J가 되는 경우는 2가지 방법이 있다. A -> B -> ... -> J 정방향으로 가는 경우 9번의 변경이 있고, A -> Z -> Y -> ... -> J 역방향으로 가는 경우 17번의 변경이 필요하다. 이 중 더 작은 숫자인 9가 A를 J로 만드는 데 필요한 횟수가 된다.
이제 0번째 글자는 맞춰졌으니 다른 글자를 변경하러 이동하여야 한다.

커서를 1번째 index로 옮기거나, 뒤로 돌아 name.length - 1인 2번째 index로 옮길 수 있다.

정방향인 1번째로 옮기는 경우, name[1]이 'A'이므로 변경하지 않아도 된다.(이동 횟수 1) 그러므로 커서를 2번째로 옮길 수 있다.(이동 횟수 1) 2번째에서 'A'를 'Z'으로 변경하는 데 걸리는 횟수는 1회이다. 정방향으로 옮긴 경우, 총 취한 액션의 횟수는 9 + 1 + 1 + 1 = 11 이 된다.

만약 index를 뒤로 돌아갔다고 가정해보자.(이동 횟수 1) name[name.length-1], 즉 name[2]인 'Z'로 'A'를 변경하는 데 걸리는 횟수는 1이다. 그다음 name[name.length - 1 - 1]인 name[1]은 'A'이므로 변경하지 않아도 된다. 또한 더이상 변경해야 할 글자가 없으므로 name[1]으로 이동할 필요도 없다. 역방향으로 옮긴 경우, 총 취한 액션의 횟수는 9 + 1 = 10이다.

최종적으로 필요한 결과는 `각 자리의 알파벳 변경 횟수 총합` + `커서 이동 횟수`가 된다.

**missing point**

- 앞으로 갔다가 뒤로 갈수도 있고, 뒤로 가다가 앞으로 돌아갈 수도 있다는 점
  - 앞으로 가거나 뒤로 가는 한 방향만 생각했었다.

**문제풀이**

`getMinInOneIdx(to)` 함수는 'A'로부터 target 알파벳으로 변경하는 데 걸리는 횟수를 구하는 함수이다.

```js
function getMinInOneIdx(to) {
  const res =
    to.charCodeAt() - "A".charCodeAt() > 13
      ? "Z".charCodeAt() - to.charCodeAt() + 1
      : to.charCodeAt() - "A".charCodeAt();
  return res;
}
```

1. `let cnt = name.length - 1;` : 커서의 이동 경우 중 가능한 최대의 이동 횟수는 0번째서부터 뒤로 가면서 모두 확인하는 경우가 될 것이다. 이는 0번째는 이동횟수에 포함되지 않으므로, name의 총 길이 - 1이 된다.

2. A가 name에 한 개도 없는 경우, 이동 횟수를 줄일 수 있는 방법이 없으므로, name.length - 1이 총 이동 횟수가 되며, 모든 글자를 getMinInOneIdx(el)에 넣고 계산한 결과의 총합이 알파벳 변경 횟수가 된다.

```js
if (!new Set(name.split("")).has("A")) {
  answer += cnt;
  name.split("").forEach((element) => {
    answer += getMinInOneIdx(element);
  });
  return answer;
}
```

3. 문제의 요지는 여기에 있다. 'A'가 있는 경우이다.
   'A'가 몇 개 있으며, 문자열에서 어느 위치에 있는지에 따라서 커서의 이동 방향이 결정된다고 볼 수 있다. 커서가 이동하는 경우는 세가지로 볼 수 있다.

   1. 오른쪽 방향으로 이동하다가 'A'세트를 만나면, 뒤로 돌아 가다가 아까 봤던 'A'세트의 마지막 'A'를 만나면 정지한다.
   2. 혹은 오른쪽 방향으로 'A'를 만나던 말던 직진한다.
   3. 혹은 처음부터 왼쪽 방향으로 이동하다가 'A'세트를 만나면 다시 뒤로 돌아 오른쪽 방향으로 가다가 아까 봤던 'A'세트의 첫번째 'A'를 만나면 정지하는 것이다.

   여기에서 'A'는 한번만 나오지 않을 수 있다. 따라서 앞의 A는 무시하고 뒤의 A를 기준으로 뒤로 돌아가야하는 상황이 더 이로운 상황이 있을 수도 있다. 'BAAAABABBB'가 그 예시가 될 수 있다. 정방향으로 가는 경우, 9번 이동한다. 앞의 A에서 유턴하는 경우, 5번 이동한다. 뒤의 A에서 유턴하는 경우, 13번 이동한다. 역방향으로 이동하여 먼저 만나는 A에서 유턴하는 경우, 11번 이동한다. 역방향으로 이동하여 두번째로 만나는 'A'에서 유턴하는 경우, 10번 이동한다.

4. 먼저 현재 확인 중인 index의 다음 index에 'A'가 있다면 몇 번째 index까지 있는지 확인한다. 문자열이 'BBAAABA'이고, 현재 index가 1이라면, index + 1인 2부터 3개의 'A'가 연속되므로, nextIdx는 5가 된다. 만일 현재 index가 5이라면, index + 1인 6부터 1개의 'A'가 연속되므로, nextIdx는 6이 된다.

```js
for (let i = 0; i < name.length; i++) {
  let nextIdx = i + 1;
  while (nextIdx <= name.length - 1 && name[nextIdx] === "A") {
    nextIdx += 1;
  }
}
```

5. '3.'번의 내용에 따라 매 위치에서 cnt를 가능한 최소 값으로 갱신할 수 있다. 처음에는 가능한 최소 중에 최대인 'name.length-1'과 오른쪽으로 가면서 'A'를 만나면 유턴하는 경우와 왼쪽으로 가다가 'A'를 만나고 유턴하는 경우 중 최소인 것을 cnt로 계속 갱신하고, 모든 index에서 이를 확인한 것 중 최소 값이 answer이 된다.  
   여기에서 i에 2를 곱하는 이유는 i가 내가 만난 'A'의 전 index이고, 그 index에서 유턴을 하면 두 번 지나가게 되기 때문이다. 반대로 (name.length - nextIdx)에 2를 곱하는 이유도 마찬가지 이다.

````js
cnt = Math.min(
    cnt,
    i * 2 + name.length - nextIdx, // 오른쪽으로 갔다가 A만나서 뒤로 돌아오는 경우
    (name.length - nextIdx) * 2 + i // 뒤로 갔다가 마지막 A 세트 만나고 다시 앞으로 가는 경우
  );```
````

최종 코드는 아래와 같다.

```js
function solution(name) {
  var answer = 0;
  let cnt = name.length - 1;

  // A가 없다면 -> 모든 곳 다 돌아야 함
  if (!new Set(name.split("")).has("A")) {
    answer += cnt;
    name.split("").forEach((element) => {
      answer += getMinInOneIdx(element);
    });
    return answer;
  } else {
    // A가 있다면 ? 마지막에 A의 개수가 제일 많이 이어진 곳이 되어야 이동 횟수가 최소가 됨
    // 오른쪽으로 가다가 A를 만나면 다시 돌아갈지, 오른쪽으로 쭉 갈지, 왼쪽으로 쭉 갈지
    for (let i = 0; i < name.length; i++) {
      answer += getMinInOneIdx(name[i]);
      let nextIdx = i + 1;
      while (nextIdx < name.length && name[nextIdx] === "A") {
        // A의 끝나는 index 확인
        nextIdx += 1;
      }
      cnt = Math.min(
        cnt,
        i * 2 + name.length - nextIdx, // 오른쪽으로 갔다가 A만나서 뒤로 돌아오는 경우
        (name.length - nextIdx) * 2 + i // 뒤로 갔다가 마지막 A 세트 만나고 다시 앞으로 가는 경우
      );
    }
  }
  answer += cnt;
  return answer;
}
```
