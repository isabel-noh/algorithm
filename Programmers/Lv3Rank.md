# Programmers - Graph - Rank

[Programmers - Graph - Rank](https://school.programmers.co.kr/learn/courses/30/lessons/49191)

### 문제 설명

n명의 권투선수가 권투 대회에 참여했고 각각 1번부터 n번까지 번호를 받았습니다. 권투 경기는 1대1 방식으로 진행이 되고, 만약 A 선수가 B 선수보다 실력이 좋다면 A 선수는 B 선수를 항상 이깁니다. 심판은 주어진 경기 결과를 가지고 선수들의 순위를 매기려 합니다. 하지만 몇몇 경기 결과를 분실하여 정확하게 순위를 매길 수 없습니다.

선수의 수 n, 경기 결과를 담은 2차원 배열 results가 매개변수로 주어질 때 정확하게 순위를 매길 수 있는 선수의 수를 return 하도록 solution 함수를 작성해주세요.

### 제한사항

- 선수의 수는 1명 이상 100명 이하입니다.
- 경기 결과는 1개 이상 4,500개 이하입니다.
- results 배열 각 행 [A, B]는 A 선수가 B 선수를 이겼다는 의미입니다.
- 모든 경기 결과에는 모순이 없습니다.

### 문제 분석

다른 사람들의 풀이 방법을 참고하여 풀이해 보았다.
`정확하게 순위를 매길 수 있는 선수의 수`란 뭘까.  
그래프 문제라고 생각했을 때, 다른 노드들과 모두 연결되어있는 노드라고 할 수 있겠다.  
플로이드-와샬 알고리즘을 사용하면 풀이할 수 있다.  
먼저, a가 b를 이긴다는 것을 그래프에 rank[a][b] = 1로 표기하고, 이는 즉 b는 a에 진다는 의미이기 때문에 rank[b][a] = -1로 표기하였다.  
여기에서 중요한 포인트! a가 i에게 이기고, i가 b에게 이긴다면 `a > i > b` -> a는 b에게 이긴다. `a > b`  
반대도 똑같이 적용된다.  
이것을 생각하고, a, b를 기준으로 모든 다른 숫자들과 비교하여서 위의 규칙이 적용되는지 확인하여 rank를 업데이트하면, 확인 가능한 i와 j간의 모든 관계가 나오게 된다.
그러면 각 줄에서 0의 개수가 본인과 본인의 관계를 제외하고 0개, 즉 모든 사람들과 이기고 지는 관계가 성립한 사람이라면 등수를 확실히 알 수 있다는 뜻이 된다.

### 코드

```js
function solution(n, results) {
  var answer = 0;
  const rank = Array.from({ length: n + 1 }, () => Array(n + 1).fill(0));
  for (let i = 0; i < results.length; i++) {
    const [a, b] = results[i];
    rank[a][b] = 1; // 이기는 경우는 1
    rank[b][a] = -1; // 지는 경우는 -1
  }
  for (let i = 0; i < n + 1; i++) {
    for (let a = 0; a < n + 1; a++) {
      // a가 i를 이기고, i가 b를 이기면 a가 b를 이김
      for (let b = 0; b < n + 1; b++) {
        // a가 i에게 지고, i가 b에게 지면 a가 b에게 짐
        if (rank[a][i] === 1 && rank[i][b] === 1) {
          rank[a][b] = 1;
          rank[b][a] = -1;
        }
        if (rank[a][i] === -1 && rank[i][b] === -1) {
          rank[a][b] = -1;
          rank[b][a] = 1;
        }
      }
    }
  }
  for (let i = 1; i < n + 1; i++) {
    const [a, ...args] = rank[i];
    let cntZero = 0;
    args.forEach((element) => {
      if (element === 0) cntZero++;
    });
    if (cntZero === 1) answer++;
  }
  return answer;
}

solution(5, [
  [4, 3],
  [4, 2],
  [3, 2],
  [1, 2],
  [2, 5],
]);
```

### 그래프

### 플로이드 와샬 알고리즘

- 모든 지점에서 다른 모든 지점까지의 최단 경로를 모두 구해야하는 경우
  2차원 테이블에 최단 거리 정보를 저장한다. (모든 지점에서 다른 모든 지점까지의 최단 거리를 저장해야 하기 때문이다.)

```js
const graph = Array.from({ length: n + 1 }, () => Array(n + 1).fill(false));
for (let i = 0; i < n + 1; i++) {
  // 자기에서 자기로 가는 것은 0
  for (let j = 0; j < n + 1; j++) {
    if (i == j) {
      graph[i][j] = 0;
    }
  }
}
for (let i = 0; i < m; i++) {
  // 간선의 거리를 표시
  const [a, b, c] = m[i];
  graph[a][b] = c;
}
// 플로이드 워셜 알고리즘
for (let i = 0; i < n + 1; i++) {
  // i번째 노드를 거쳐서 가는 경우
  for (let a = 0; a < n + 1; a++) {
    for (let b = 0; b < n + 1; b++) {
      graph[a][b] = Math.min(graph[a][b], graph[a][i] + graph[i][b]);
    }
  }
}
```

- 시간 복잡도는 O(N^3)
  노드의 개수가 N개 일 때, N번의 단계를 수행하며, 단계마다 O(N^2)의 연산을 통해 '현재 노드를 거쳐 가는 모든 경로'를 고려한다. 따라서 시간 복잡도는 총 O(N^3)이다.

### 다익스트라 알고리즘

- 한 지점에서 다른 특정 지점까지의 `최단 경로`를 구하는 알고리즘
- 단계마다 최단 거리를 가지는 노드를 하나씩 반복적으로 선택한다. 이후 해당 노드를 거쳐가는 경로를 확인하며 최단 거리 테이블을 갱신하는 방식으로 동작한다.
- `최단 경로 구해야하는 문제 상황의 경우들`
  - 한 지점에서 다른 특정 지점까지의 최단 경로
  - 모든 지점에서 다른 모든 지점까지의 최단 경로
  - 한 지점에서 다른 모든 지점까지의 최단 경로
- 각 지점은 그래프에서 노드로 표현
- 지점 간 연결된 도로는 그래프에서 간선으로 표현
