# Programmers - Binary Search - 입국심사

[ Programmers - Binary Search - 입국심사] (https://school.programmers.co.kr/learn/courses/30/lessons/43238)

### 문제 설명

n명이 입국심사를 위해 줄을 서서 기다리고 있습니다. 각 입국심사대에 있는 심사관마다 심사하는데 걸리는 시간은 다릅니다.

처음에 모든 심사대는 비어있습니다. 한 심사대에서는 동시에 한 명만 심사를 할 수 있습니다. 가장 앞에 서 있는 사람은 비어 있는 심사대로 가서 심사를 받을 수 있습니다. 하지만 더 빨리 끝나는 심사대가 있으면 기다렸다가 그곳으로 가서 심사를 받을 수도 있습니다.

모든 사람이 심사를 받는데 걸리는 시간을 최소로 하고 싶습니다.

입국심사를 기다리는 사람 수 n, 각 심사관이 한 명을 심사하는데 걸리는 시간이 담긴 배열 times가 매개변수로 주어질 때, 모든 사람이 심사를 받는데 걸리는 시간의 최솟값을 return 하도록 solution 함수를 작성해주세요.

### 제한사항

- 입국심사를 기다리는 사람은 1명 이상 1,000,000,000명 이하입니다.
- 각 심사관이 한 명을 심사하는데 걸리는 시간은 1분 이상 1,000,000,000분 이하입니다.
- 심사관은 1명 이상 100,000명 이하입니다.

### 코드 - 시간 초과

```js
function solution(n, times) {
  var answer = 0;
  times.sort((a, b) => a - b);
  const nextStartAt = [...times]; // 다음 시작 시간 표기

  for (let i = 0; i < n; i++) {
    if (i === 0) {
      nextStartAt[i] += times[i];
    } else {
      // 다음 시작 시간 중에 가장 짧은 시간을 선택
      const min = Math.min(...nextStartAt);
      const idx = nextStartAt.indexOf(min);
      nextStartAt[idx] += times[idx];
      if (i === n - 1) answer = min;
    }
  }
  return answer;
}
```

### 코드 - 이진 탐색

왜 이진 탐색인지 이해하지 못하여 다른 사람의 코드를 참고하여 풀이하였다.  
이진탐색이란 내가 찾으려는 값을 `범위` 라는 것을 이용하여 찾는 방법이다.  
입국심사를 기다리는 사람은 너무 많고, 심사관은 100,000명 이하이기 때문에 심사관을 기준으로 계산한다.

이 문제는 최소로 걸리는 시간을 구하는 문제이다.  
그렇다면 최대로 걸리는 시간은 얼마일까 ? times를 정렬했다고 가정하면, `times[times.length - 1] * n`이 걸릴 것이다.

만약 입국심사 대기 인원이 6명이라고 하면, 최대로 걸리는 시간은 60이다.  
6명이 입국 심사하는 데 최대로 걸리는 시간을 고려했을 때, 심사관이 2명이고 시간이 [7, 10]으로 걸린다면, 한 심사관이 몇 명씩 심사할 수 있을까? [60/7, 60/10] = 총 14명 심사할 수 있을 것이다.  
14명? 14명은 6명의 2배 보다 많다.  
그러면 최대로 걸리는 시간을 60의 1/2인 30으로 가정하자.  
6명이 입국 심사하는 데 30이 걸린다고 가졍했을 때, 심사관 2명이서 처리할 수 있는 사람은 [30/7, 30/10] = 7명이다.  
7명도 6명보다 많은데?  
그러면 이번에는 최대로 걸리는 시간을 (0 + 29)/2 = 14로 가정하자. 이번에는 심사관 2명이서 처리할 수 있는 사람은 [14/7, 14/10] = 3명이다.  
이번엔 모자르다. 시간을 (15+29)/2 = 22으로 가정하면, [22/7, 22/10] = 5명이다. 한 번만 더! 시간을 (23+29)/2 = 26, [26/7, 26/10] = 5명이다.  
마지막이다. 시간을 (28+30)/2 = 29으로 가정하면, [29/7, 29/10] = 6명이 나온다.

즉, 이진 탐색을 통해 여기서 구하는 것은 n명을 심사하는 데 최소로 걸리는 시간을 탐색하는 것이다.  
(총 걸리는 시간 / 1명을 입국 심사 하는 데 걸리는 시간)은 한 심사관이 총 걸리는 시간 동안 처리할 수 있는 인원의 수가 된다.

이 문제에서 이분 탐색에서의 범위는 [ 0분 ~ 최대로 걸리는 시간 ]이다.  
범위를 어떻게 잡느냐가 문제였다.

```js
function solution(n, times) {
  var answer = 0;
  times.sort((a, b) => a - b);

  let min = 0;
  let max = times[times.length - 1] \* n;

  while (min <= max) {
    const mid = Math.floor((min + max) / 2);

    let capacity = 0;

    for (let i = 0; i < times.length; i++) {
      capacity += Math.floor(mid / times[i]);
    }
    if (capacity >= n) {
      answer = mid;
      max = mid - 1;
    } else {
      min = mid + 1;
    }

  }
  return answer;
}

solution(6, [7, 10]); // 28
```

### 틀린 부분

capacity가 정확히 n과 일치하지 않을 수 있다.  
처리 가능한 인원보다 많아야 하지 적을 수는 없으며, capacity와 n이 당장은 같더라도 더 최소의 값이 나올수도 있기 때문에, capacity >= n인 경우에도 answer = mid로 바꿔주고, return하지 않고, 끝까지 계속 확인하여야 한다.

나의 원래 코드는 `capacity === n`인 경우에 `answer`를 `mid`로 설정하고, 즉시 return 한다.

- 이렇게 하면 최적의 값을 찾지 못할 가능성이 있다. 중간에 탐색을 중단하게 되면 최적의 값이 아닌 첫 번째로 찾은 값만 반환하게 되어, 더 나은 값을 찾지 못할 수 있다.
- 위의 코드의 경우에는, `capacity >= n`인 경우에도 탐색 범위를 계속 좁혀나가면서 더 나은 `answer` 값을 갱신한다.

```js
if (capacity === n) {
  answer = mid;
  return answer;
} else if (capacity > n) {
  max = mid - 1;
} else {
  min = mid + 1;
}
```
